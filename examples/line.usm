( draw routines )

:dev/r fff8 ( std read port )
:dev/w fff9 ( std write port )

;x_ 2 ;y_ 2 ;color 1
;x0 2 ;y0 2 ;x1 2 ;y1 2 ;dx 2 ;dy 2 ;err1 2 ;err2 2

|0100 @RESET

	( set dev/write to screen ) 
	,01 ,dev/w STR 

	( positive )
	,01 ,color STR
	+0030 ,x0 STR^ +0040 ,y0 STR^
	+0100 ,x1 STR^ +0060 ,y1 STR^
	,line JSR

	,02 ,color STR
	+0020 ,x0 STR^ +0010 ,y0 STR^
	+0090 ,x1 STR^ +0070 ,y1 STR^
	,line JSR

	,03 ,color STR
	+0010 ,x0 STR^ +0040 ,y0 STR^
	+0070 ,x1 STR^ +0060 ,y1 STR^
	,line JSR

	( draw control points )
	,02 ,color STR
	,x0 LDR^ ,y0 LDR^ ,putpixel JSR
	,x1 LDR^ ,y1 LDR^ ,putpixel JSR

	,redraw JSR

BRK

@line
	,x0 LDR^ ,x_ STR^ ,y0 LDR^ ,y_ STR^                   ( start at x0,y0 )
	,x1 LDR^ ,x0 LDR^ ,diff16sub JSR ,dx STR^             ( int dx = abs[x1 - x0] )
	,y1 LDR^ ,y0 LDR^ ,diff16sub JSR -0001 MUL!^ ,dy STR^ ( int dy = -abs[y1 - y0] )
	,dx LDR^ ,dy LDR^ ADD!^ ,err1 STR^                    ( int err1 = dx + dy, e2; )
	@lineloop
	,x_ LDR^ ,y_ LDR^ ,putpixel JSR                       ( draw )
	@line-x
	,err1 LDR^ +0002 MUL!^ ,err2 STR^                     ( e2 = 2 * err; )
	,err2 LDR^ ,dy LDR^ LTH!^ ,line-y ROT JMP? POP^ 	  ( e2 >= dy )
		,err1 LDR^ ,dy LDR^ ADD!^ ,err1 STR^ 			  ( err1 += dy; )
		,x_ LDR^ +0001 ADD!^ ,x_ STR^                     ( y0 += y0 < y1 ? 1 : -1; )
	@line-y
	,err2 LDR^ ,dx LDR^ GTH!^ ,line-end ROT JMP? POP^     ( e2 <= dx )
		,err1 LDR^ ,dx LDR^ ADD!^ ,err1 STR^              ( err1 += dx; )
		,y_ LDR^ +0001 ADD!^ ,y_ STR^                     ( y0 += y0 < y1 ? 1 : -1; )
	@line-end
	,x_ LDR^ ,x1 LDR^ NEQ!^ ,lineloop ROT JMP? POP^       ( loop )
	RTS

@redraw
	,0000 IOW^
	,0000 IOW^
	,00 IOW
	,01 IOW
	RTS

@putpixel 
	IOW^ ( y short )
	IOW^ ( x short )
	,color LDR IOW  ( color byte )
	,00 IOW  ( redraw byte )
	RTS

@diff16
	OVR^ OVR^ GTH^ ,diff16sub ROT JMP? POP^
	SWP^ @diff16sub SUB^
RTS

|c000 @FRAME BRK 
|d000 @ERROR BRK 
|FFFA .RESET .FRAME .ERROR
