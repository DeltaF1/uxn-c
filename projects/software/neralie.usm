( Prints Neralie time to console.

  Formatting isn't great, but it demonstrates that
  the conversion works correctly. It's a little jittery
  at the beginning because the FPS calculation isn't
  accurate, so in the finished program delay showing
  pulses for up to the first two seconds.

  When compiled to bin/boot.rom, the faketime package
  allows easy testing of midnight roll-over:

  faketime '23:59:42' bin/emulator bin/boot.rom
)

;fps { current 1 next 1 second 1 }
;number { started 1 count 1 }
;linee { var 2 }
;neralie { n6543 2 n21 1 }

|0100 ;Console { pad 8 char 1 byte 1 short 2 }
|0110 ;Screen { width 2 height 2 pad 4 x 2 y 2 color 1 }
|0120 ;Sprite { pad 8 x 2 y 2 addr 2 color 1 }
|0190 ;Time { year 2 month 1 day 1 hour 1 minute 1 second 1 dow 1 doy 2 isdst 1 pad 4 get 1 }
|01F0 .RESET .FRAME .ERROR ( vectors )
|01F8 [ 13fd 1ef3 1bf2 ] ( palette )

|0200 @RESET
	#3c =fps.current
	@ERROR BRK

@FRAME
	,update-fps JSR2
	,neralie-calc JSR2
	BRK

	,font #00 ~number.count #08 MUL ADD2 =Sprite.addr
	#02 =Sprite.color
	#0000 #00 ~number.count DUP2 ,h JSR2
	~number.count #01 ADD =number.count

@neralie-calc
	( add up fractions of a pulse )
	#0120 #00 ~Time.hour MUL2
	#00c0 #00 ~Time.minute MUL2 ADD2
	#00f8 #00 ~Time.second MUL2 ADD2
	#0271 #00 ~fps.next MUL2 #00 ~fps.current DIV2 #0008 MUL2 ADD2
	#01b0 DIV2

	( add up units and tens of pulses )
	#0042 #00 ~Time.hour MUL2 ADD2
	#005e #00 ~Time.minute MUL2 ADD2
	#000b #00 ~Time.second MUL2 ADD2
	DUP2 #0064 DIV2 DUP2 STH2 #0064 MUL2 SUB2 =neralie.n21 POP

	( add up hundreds of pulses + 10 x beats )
	STH2r
	#01a0 #00 ~Time.hour MUL2 ADD2
	#0006 #00 ~Time.minute MUL2 ADD2 =neralie.n6543

	~neralie.n6543 ,print-short-decimal JSR2
	#20 =Console.char
	~neralie.n21 ,print-byte-decimal JSR2
	#0a =Console.char
	JMP2r

@h ( x1₂ x2₂ y₂ -- )
	=Screen.y
	,Screen.x =linee.var
	^line JMP

@v ( y1₂ y2₂ x₂ -- )
	=Screen.x
	,Screen.y =linee.var
	( ^line JMP is redundant )

@line ( v1₂ v2₂ -- )
	OVR2 OVR2 LTH2 #01 JNZ SWP2
	STH2

	$loop
	DUP2 DUP2r STH2r GTH2 ^$end JNZ
	DUP2 ~linee.var STR2
	#03 =Screen.color
	#0001 ADD2
	^$loop JMP

	$end
	POP2 POP2r
	JMP2r

@update-fps
	#00 =Time.get
	~fps.next #01 ADD =fps.next
	~Time.second ~fps.second NEQ JMP JMP2r
	~Time.second =fps.second
	~fps.next =fps.current

	~fps.next ^print-byte-decimal JSR
	,strings-fps ^print-string JSR

	#00 =fps.next
	JMP2r

@print-byte-decimal ( byte₁ -- )
	#00 =number.started
	DUP #64 DIV DUP ^$digit JSR #64 MUL SUB
	DUP #0a DIV DUP ^$digit JSR #0a MUL SUB
	^$digit JSR
	~number.started ^$end JNZ
	#30 =Console.char
	$end JMP2r

	$digit
	OVR ~number.started ORA #02 JNZ
	POP JMP2r
	#30 ADD =Console.char
	#01 =number.started
	JMP2r

@print-string ( string₂ -- )
	DUP2 PEK2 DUP ^$not-end JNZ

	$end
	POP POP2 JMP2r

	$not-end
	=Console.char
	#0001 ADD2 ^print-string JMP

@print-short-decimal ( short₂ -- )
	#00 =number.started
	DUP2 #2710 DIV2 DUP2 ^$digit JSR #2710 MUL2 SUB2
	DUP2 #03e8 DIV2 DUP2 ^$digit JSR #03e8 MUL2 SUB2
	DUP2 #0064 DIV2 DUP2 ^$digit JSR #0064 MUL2 SUB2
	DUP2 #000a DIV2 DUP2 ^$digit JSR #000a MUL2 SUB2
	^$digit JSR
	~number.started ^$end JNZ
	#30 =Console.char
	$end JMP2r

	$digit
	SWP POP
	OVR ~number.started ORA #02 JNZ
	POP JMP2r
	#30 ADD =Console.char
	#01 =number.started
	JMP2r

@strings
	$fps [ 20 fps 0a 00 ]

@font
[
	003c 464a 5262 3c00 0018 0808 0808 1c00
	003c 4202 3c40 7e00 003c 421c 0242 3c00
	000c 1424 447e 0400 007e 407c 0242 3c00
	003c 407c 4242 3c00 007e 0204 0810 1000
	003c 423c 4242 3c00 003c 4242 3e02 3c00
]

